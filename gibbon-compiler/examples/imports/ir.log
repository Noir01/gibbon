 ! Responding to env Var: GIBBON_DEBUG=4
 ! We set DEBUG based on command-line verbose arg: 4
================================================================================

desugaring module: ImportAliased

- imports: ["Addtwo","Addone","AddTree"]

- aliases: fromList [(Var "Addtwo",Var "T"),(Var "Addone",Var "O"),(Var "AddTree",Var "Tree")]

- imports: fromList [(Var "Addtwo",(Var "T",True,Nothing)),(Var "Addone",(Var "O",True,Nothing)),(Var "AddTree",(Var "Tree",False,Nothing))]

================================================================================

desugaring module: Addtwo

- imports: ["AddTree"]

- aliases: fromList [(Var "AddTree",Var "AddTree")]

- imports: fromList [(Var "AddTree",(Var "AddTree",False,Nothing))]

================================================================================

desugaring module: AddTree

- imports: []

- aliases: fromList []

- imports: fromList []

================================================================================

desugaring module: Addone

- imports: ["AddTree"]

- aliases: fromList [(Var "AddTree",Var "AddTree")]

- imports: fromList [(Var "AddTree",(Var "AddTree",False,Nothing))]

 [compiler] pipeline starting, parsed program: 
================================================================================
Prog {ddefs = [(AddTree.Tree,
                DDef {tyName = "AddTree.Tree",
                      tyArgs = [],
                      dataCons = [("Leaf", [(False, IntTy)]),
                                  ("Node",
                                   [(False, PackedTy "AddTree.Tree" []),
                                    (False, PackedTy "AddTree.Tree" [])])]})],
      fundefs = [(Addtwo.add,
                  FunDef {funName = "Addtwo.add",
                          funArgs = [t],
                          funTy = ForAll []
                                         (ArrowTy [PackedTy "AddTree.Tree" []]
                                                  (PackedTy "AddTree.Tree" [])),
                          funBody = CaseE (VarE "t")
                                          [("Leaf",
                                            [(x, MetaTv $2)],
                                            DataConE (MetaTv $1)
                                                     "Leaf"
                                                     [PrimAppE AddP [VarE "x",LitE 2]]),
                                           ("Node",
                                            [(x1, MetaTv $4),(x2, MetaTv $5)],
                                            DataConE (MetaTv $3)
                                                     "Node"
                                                     [AppE "Addtwo.add" [] [VarE "x1"],
                                                      AppE "Addtwo.add" [] [VarE "x2"]])],
                          funMeta = FunMeta {funRec = NotRec,
                                             funInline = NoInline,
                                             funCanTriggerGC = False,
                                             funOptLayout = NoLayoutOpt,
                                             userConstraintsDataCon = Nothing}}),
                 (Addtwo.sub,
                  FunDef {funName = "Addtwo.sub",
                          funArgs = [t],
                          funTy = ForAll []
                                         (ArrowTy [PackedTy "AddTree.Tree" []]
                                                  (PackedTy "AddTree.Tree" [])),
                          funBody = CaseE (VarE "t")
                                          [("Leaf",
                                            [(x, MetaTv $8)],
                                            DataConE (MetaTv $7)
                                                     "Leaf"
                                                     [PrimAppE SubP [VarE "x",LitE 2]]),
                                           ("Node",
                                            [(x1, MetaTv $10),(x2, MetaTv $11)],
                                            DataConE (MetaTv $9)
                                                     "Node"
                                                     [AppE "Addtwo.sub" [] [VarE "x1"],
                                                      AppE "Addtwo.sub" [] [VarE "x2"]])],
                          funMeta = FunMeta {funRec = NotRec,
                                             funInline = NoInline,
                                             funCanTriggerGC = False,
                                             funOptLayout = NoLayoutOpt,
                                             userConstraintsDataCon = Nothing}}),
                 (Addone.add,
                  FunDef {funName = "Addone.add",
                          funArgs = [t],
                          funTy = ForAll []
                                         (ArrowTy [PackedTy "AddTree.Tree" []]
                                                  (PackedTy "AddTree.Tree" [])),
                          funBody = CaseE (VarE "t")
                                          [("Leaf",
                                            [(x, MetaTv $2)],
                                            DataConE (MetaTv $1)
                                                     "Leaf"
                                                     [PrimAppE AddP [VarE "x",LitE 1]]),
                                           ("Node",
                                            [(x1, MetaTv $4),(x2, MetaTv $5)],
                                            DataConE (MetaTv $3)
                                                     "Node"
                                                     [AppE "Addone.add" [] [VarE "x1"],
                                                      AppE "Addone.add" [] [VarE "x2"]])],
                          funMeta = FunMeta {funRec = NotRec,
                                             funInline = NoInline,
                                             funCanTriggerGC = False,
                                             funOptLayout = NoLayoutOpt,
                                             userConstraintsDataCon = Nothing}}),
                 (Addone.sub,
                  FunDef {funName = "Addone.sub",
                          funArgs = [t],
                          funTy = ForAll []
                                         (ArrowTy [PackedTy "AddTree.Tree" []]
                                                  (PackedTy "AddTree.Tree" [])),
                          funBody = CaseE (VarE "t")
                                          [("Leaf",
                                            [(x, MetaTv $8)],
                                            DataConE (MetaTv $7)
                                                     "Leaf"
                                                     [PrimAppE SubP [VarE "x",LitE 1]]),
                                           ("Node",
                                            [(x1, MetaTv $10),(x2, MetaTv $11)],
                                            DataConE (MetaTv $9)
                                                     "Node"
                                                     [AppE "Addone.sub" [] [VarE "x1"],
                                                      AppE "Addone.sub" [] [VarE "x2"]])],
                          funMeta = FunMeta {funRec = NotRec,
                                             funInline = NoInline,
                                             funCanTriggerGC = False,
                                             funOptLayout = NoLayoutOpt,
                                             userConstraintsDataCon = Nothing}}),
                 (AddTree.sum,
                  FunDef {funName = "AddTree.sum",
                          funArgs = [t],
                          funTy = ForAll [] (ArrowTy [PackedTy "AddTree.Tree" []] IntTy),
                          funBody = CaseE (VarE "t")
                                          [("Leaf", [(v, MetaTv $1)], VarE "v"),
                                           ("Node",
                                            [(l, MetaTv $2),(r, MetaTv $3)],
                                            PrimAppE AddP
                                                     [AppE "sum" [] [VarE "l"],
                                                      AppE "sum" [] [VarE "r"]])],
                          funMeta = FunMeta {funRec = NotRec,
                                             funInline = NoInline,
                                             funCanTriggerGC = False,
                                             funOptLayout = NoLayoutOpt,
                                             userConstraintsDataCon = Nothing}})],
      mainExp = Just (AppE "AddTree.sum"
                           []
                           [AppE "Addtwo.add"
                                 []
                                 [AppE "Addone.add"
                                       []
                                       [DataConE (MetaTv $0)
                                                 "Tree.Node"
                                                 [DataConE (MetaTv $1) "Tree.Leaf" [LitE 1],
                                                  DataConE (MetaTv $2) "Tree.Leaf" [LitE 2]]]]],
                      MetaTv $3)}

 [compiler] Running pass, renameModules
Pass output:
================================================================================
data AddTree_Tree_4 = Leaf Int | 
                      Node (Packed AddTree_Tree_4 []) (Packed AddTree_Tree_4 [])
{meta: FunMeta {funRec = NotRec, funInline = NoInline, funCanTriggerGC = False, funOptLayout = NoLayoutOpt, userConstraintsDataCon = Nothing}}
Addtwo_add_5 :: forall. ((Packed AddTree_Tree_4 []) -> (Packed AddTree_Tree_4 []))
Addtwo_add_5 t =
    case t of
        Leaf x::$2 ->
            (Leaf $1 x + 2)
        Node x1::$4 x2::$5 ->
            (Node $3 (Addtwo_add_5 [] x1) (Addtwo_add_5 [] x2))

{meta: FunMeta {funRec = NotRec, funInline = NoInline, funCanTriggerGC = False, funOptLayout = NoLayoutOpt, userConstraintsDataCon = Nothing}}
Addtwo_sub_6 :: forall. ((Packed AddTree_Tree_4 []) -> (Packed AddTree_Tree_4 []))
Addtwo_sub_6 t =
    case t of
        Leaf x::$8 ->
            (Leaf $7 x - 2)
        Node x1::$10 x2::$11 ->
            (Node $9 (Addtwo_sub_6 [] x1) (Addtwo_sub_6 [] x2))

{meta: FunMeta {funRec = NotRec, funInline = NoInline, funCanTriggerGC = False, funOptLayout = NoLayoutOpt, userConstraintsDataCon = Nothing}}
Addone_add_7 :: forall. ((Packed AddTree_Tree_4 []) -> (Packed AddTree_Tree_4 []))
Addone_add_7 t =
    case t of
        Leaf x::$2 ->
            (Leaf $1 x + 1)
        Node x1::$4 x2::$5 ->
            (Node $3 (Addone_add_7 [] x1) (Addone_add_7 [] x2))

{meta: FunMeta {funRec = NotRec, funInline = NoInline, funCanTriggerGC = False, funOptLayout = NoLayoutOpt, userConstraintsDataCon = Nothing}}
Addone_sub_8 :: forall. ((Packed AddTree_Tree_4 []) -> (Packed AddTree_Tree_4 []))
Addone_sub_8 t =
    case t of
        Leaf x::$8 ->
            (Leaf $7 x - 1)
        Node x1::$10 x2::$11 ->
            (Node $9 (Addone_sub_8 [] x1) (Addone_sub_8 [] x2))

{meta: FunMeta {funRec = NotRec, funInline = NoInline, funCanTriggerGC = False, funOptLayout = NoLayoutOpt, userConstraintsDataCon = Nothing}}
AddTree_sum_9 :: forall. ((Packed AddTree_Tree_4 []) -> Int)
AddTree_sum_9 t =
    case t of
        Leaf v::$1 ->
            v
        Node l::$2 r::$3 ->
            (sum [] l) + (sum [] r)

gibbon_main :: $3
gibbon_main = (AddTree_sum_9 [] (Addtwo_add_5 [] (Addone_add_7 [] (Tree.Node $0 (Tree.Leaf $1 1) (Tree.Leaf $2 2)))))

 [compiler] Running pass, freshen
Pass output:
================================================================================
data AddTree_Tree_4 = Leaf Int | 
                      Node (Packed AddTree_Tree_4 []) (Packed AddTree_Tree_4 [])
{meta: FunMeta {funRec = NotRec, funInline = NoInline, funCanTriggerGC = False, funOptLayout = NoLayoutOpt, userConstraintsDataCon = Nothing}}
Addtwo_add_5 :: forall. ((Packed AddTree_Tree_4 []) -> (Packed AddTree_Tree_4 []))
Addtwo_add_5 t_10 =
    case t_10 of
        Leaf x_11::$2 ->
            (Leaf $1 x_11 + 2)
        Node x1_12::$4 x2_13::$5 ->
            (Node $3 (Addtwo_add_5 [] x1_12) (Addtwo_add_5 [] x2_13))

{meta: FunMeta {funRec = NotRec, funInline = NoInline, funCanTriggerGC = False, funOptLayout = NoLayoutOpt, userConstraintsDataCon = Nothing}}
Addtwo_sub_6 :: forall. ((Packed AddTree_Tree_4 []) -> (Packed AddTree_Tree_4 []))
Addtwo_sub_6 t_14 =
    case t_14 of
        Leaf x_15::$8 ->
            (Leaf $7 x_15 - 2)
        Node x1_16::$10 x2_17::$11 ->
            (Node $9 (Addtwo_sub_6 [] x1_16) (Addtwo_sub_6 [] x2_17))

{meta: FunMeta {funRec = NotRec, funInline = NoInline, funCanTriggerGC = False, funOptLayout = NoLayoutOpt, userConstraintsDataCon = Nothing}}
Addone_add_7 :: forall. ((Packed AddTree_Tree_4 []) -> (Packed AddTree_Tree_4 []))
Addone_add_7 t_18 =
    case t_18 of
        Leaf x_19::$2 ->
            (Leaf $1 x_19 + 1)
        Node x1_20::$4 x2_21::$5 ->
            (Node $3 (Addone_add_7 [] x1_20) (Addone_add_7 [] x2_21))

{meta: FunMeta {funRec = NotRec, funInline = NoInline, funCanTriggerGC = False, funOptLayout = NoLayoutOpt, userConstraintsDataCon = Nothing}}
Addone_sub_8 :: forall. ((Packed AddTree_Tree_4 []) -> (Packed AddTree_Tree_4 []))
Addone_sub_8 t_22 =
    case t_22 of
        Leaf x_23::$8 ->
            (Leaf $7 x_23 - 1)
        Node x1_24::$10 x2_25::$11 ->
            (Node $9 (Addone_sub_8 [] x1_24) (Addone_sub_8 [] x2_25))

{meta: FunMeta {funRec = NotRec, funInline = NoInline, funCanTriggerGC = False, funOptLayout = NoLayoutOpt, userConstraintsDataCon = Nothing}}
AddTree_sum_9 :: forall. ((Packed AddTree_Tree_4 []) -> Int)
AddTree_sum_9 t_26 =
    case t_26 of
        Leaf v_27::$1 ->
            v_27
        Node l_28::$2 r_29::$3 ->
            (sum [] l_28) + (sum [] r_29)

gibbon_main :: $3
gibbon_main = (AddTree_sum_9 [] (Addtwo_add_5 [] (Addone_add_7 [] (Tree.Node $0 (Tree.Leaf $1 1) (Tree.Leaf $2 2)))))

 [compiler] Running pass, typecheck
gibbon: L0.Typecheck: 
    Unknown function: sum in Var "AddTree_sum_9"
CallStack (from HasCallStack):
  error, called at src/Gibbon/L0/Typecheck.hs:83:18 in gibbon-0.3-inplace:Gibbon.L0.Typecheck
